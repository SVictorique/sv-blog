---
title: 某社交平台数据采集实现及优化历程
published: 2025-04-24
description: ''
tags: [Spider, Nodejs]
category: DataCollect
draft: false
---
# 项目背景
## 目标
收集海外某知名社交软件的数据
## 考虑因素
1. 准确性
2. 实时性
3. 稳定性
4. 低成本

# 前期调研
通过前期调研，大概可以有一下三种方案：
### 1. 使用官方API
官方高级API提供订阅方式获取数据的API，但需要承受高额的成本，放弃。
官方基础API提供了查询API，但每次查询无论数据是否更新都需要消耗次数，再考虑实时性，调用频率不能太高，成本也比较高，放弃。
### 2. 使用第三方API
第三方API虽然比官方基础API便宜一些，但原因同上，成本还是偏高，放弃。
### 3. JS逆向
对js逆向处于小白阶段，分析难度较高，需要投入很多的时间成本。
页面调用接口采用的是graphql，我对这个技术栈也不熟悉。
### 4. 使用spider
网站存在非常严格的限流规则，单纯使用浏览器自动化工具是没有办法绕开的，因此引入了指纹浏览器。
另外出于本人对java技术栈很熟悉，最终确定了使用指纹浏览器+selenium+java的方案来完成这个需求。
# 方案一：指纹浏览器+selenium+java
## 1. 指纹浏览器
指纹浏览器的核心原理是模拟一套完整的浏览器环境，所谓指纹就是指一些环境的一些参数，例如操作系统、UserAgent、时区、语言、分辨率等。
很多参数是没有办法通过代码模拟的，所以需要使用指纹浏览器。

指纹浏览器选用的是[AdsPower](https://www.adspower.net/)

通过调用start接口开启浏览器，并且通过接口返回的ws地址，创建selenium实例。
## 2. 实现过程
### 主流程
1. 将指纹浏览器分为三个批次。（防止调用接口次数超出每日最大限制，导致限流）
2. 通过配置指定的batch_id，调用接口启动该批次的指纹浏览器。
3. 每个指纹浏览器用单独的一个线程去管理。
4. 访问社交媒体的timeline页面。
5. 如果发现重定向到登录页面，执行自动登陆流程。
6. 检查账号是否被限流，被限流则进行一定时间的休眠。
7. 到timeline后，每隔一定时间进行页面滚动，以触发页面获取post更新接口。（频繁滚动是没有意义的，页面固定最小30s调用间隔）
### timeline接口监听
1. 在页面初始化完成后，使用DevTools监听timeline API。
2. 锁住主线程，防止滚动触发下一次API请求。
3. 解析API内容。
4. 如果是回复类型消息，锁住当前线程，开新窗打开回复详情页。
5. 保存回复信息，唤醒timeline线程。
6. 保存其他类型信息，唤醒主线程。
### 轮班
1. 考虑到每日访问限制和浏览器，每隔四小时执行一次。
2. 计算下一个批次号。
3. 根据browser的group_id，同一组不同批次的先执行。
4. 启动同一组下一个批次。
5. 停止同一组当前批次。（先启动，后停止防止爬去数据丢失）
### 自动同步关注列表（关注/取关）
1. 锁住主线程。
2. 从数据库表中读取每个组应该关注的人。
3. 访问用户自己的following列表。
4. 取关不在数据库的用户 。
5. 访问需要关注用户的主页，并点击关注按钮。
6. 唤醒主线程。
## 3. 存在问题
1. selenium只能同时操作一个页面，再执行timeline解析和自动同步关注列表时，无法收集消息。
2. 使用多线程，存在很多锁竞争，影响性能。
3. 线程数量远高于cpu核心数，执行效率受影响。
4. 指纹浏览器接口有1秒一次的限流策略，无法支持多浏览器的并发操作。
# 方案二：指纹浏览器+puppeteer+nodejs
## 1. 指纹浏览器优化
1. 使用命令行启动headless模式的指纹浏览器客户端，这样可以在不停止数据收集的情况下，本地启动浏览器检查账号状态。
（如果不使用命令行启动，本地登陆会强制登出远端账号）
2. 每一个group单独启动一个指纹浏览器客户端，这样只有一个组内浏览器受1秒一次的限流，同时也规避了单点故障。
## 2. 技术栈优化
+ 使用[puppeteer](https://pptr.dev/)替换selenium，主要原因是puppeteer可以支持同时在多个页面进行操作。
除此之外，puppeteer原生支持接口监听，兼容性较好
+ 由于puppeteer只支持[nodejs](https://nodejs.org/zh-cn)，因此对编程语言进行了切换。基于nodejs事件循环机制，对于IO密集型程序，可以在单线程下，拥有良好的性能。
## 3. 实现过程优化
总体采用无锁设计
### 主流程
将检查限流和登陆抽离出来，使用定时任务，使其职责更为单一，提高启动速度，增加登陆失败的容错。
### timeline接口监听
1. 不再锁定主流程，可以支持处理多个timeline请求。
2. 对于回复类消息，通过开新窗异步处理的方式，可以有效的减少延迟。
### 轮班
逻辑基本不变，但由于指纹浏览器客户端独立，多个group可以并发进行，明显提高轮班效率
### 自动同步关注列表
1. 触发方式除调用接口外，每次轮班结束后也会进行，可以在不稳定页面访问条件下，保证列表的同步。
2. 增加关注列表检查功能，使关注情况更为清晰。
# 题外话
> 千万不要透支cpu的性能，千万不要透支cpu的性能，千万不要透支cpu的性能。

重要的事情说三遍，cpu过载的情况下，会出现各种完全非预期的问题，即使使用各种方式去优化和调整，也是无法解决根本问题的。

不要问我是怎么知道的，假如你曾经在一台机器上使用105个指纹浏览器进行轮班，经常失败，死锁，甚至程序崩溃，经过各种优化未能解决。
后来又买了一台服务器，每个上面分别管理48个和57个指纹浏览器，代码完全没有变化，性能却异常的好。

那么这个时候你就会记住上面说的这句话。